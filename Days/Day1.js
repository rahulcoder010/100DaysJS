"\n/**\n * This function takes a nested array and returns a flattened array.\n * @param {Array} arr - The nested array to be flattened.\n * @returns {Array} - The flattened array.\n * @throws {Error} - Throws an error if the input is not an array.\n */\nconst flattenNestedArray = (arr) => {\n    // Check if the input is an array\n    if (!Array.isArray(arr)) {\n        throw new Error('Input must be an array');\n    }\n\n    // Initialize an empty array to hold the flattened array\n    let flatArray = [];\n\n    // Use a stack to keep track of arrays to be flattened\n    let stack = [...arr];\n\n    // Iterate while the stack is not empty\n    while (stack.length) {\n        // Pop the last element from the stack\n        let next = stack.pop();\n\n        // Check if the element is an array\n        if (Array.isArray(next)) {\n            // If the element is an array, push its elements to the stack\n            stack.push(...next);\n        } else {\n            // If the element is not an array, add it to the flattened array\n            flatArray.push(next);\n        }\n    }\n\n    // Return the flattened array\n    return flatArray.reverse();\n}\n\n// Test cases\nconsole.log(flattenNestedArray([1, 2, [3, 4, [5, 6]]])); // Expected output: [1, 2, 3, 4, 5, 6]\nconsole.log(flattenNestedArray([['a', 'b'], ['c', 'd'], ['e', 'f']])); // Expected output: ['a', 'b', 'c', 'd', 'e', 'f']\nconsole.log(flattenNestedArray([[1, 2, 3], 4, 5])); // Expected output: [1, 2, 3, 4, 5]\nconsole.log(flattenNestedArray([])); // Expected output: []\nconsole.log(flattenNestedArray([1])); // Expected output: [1]\nconsole.log(flattenNestedArray([undefined, null, [undefined, null]])); // Expected output: [undefined, null, undefined, null]\n"